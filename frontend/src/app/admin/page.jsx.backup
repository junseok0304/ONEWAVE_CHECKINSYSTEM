'use client';

import { useState, useCallback, useMemo, useEffect } from 'react';
import { useSearchParams } from 'next/navigation';
import { useQueryClient } from '@tanstack/react-query';
import { useMembers, useDashboardStats, useRealtimeCheckin, useUpdateMember, useEvents, useEventDetail, useUpdateEvent, useDeleteEvent, useManualCheckIn, useCancelCheckIn, useUpdateMemo } from '@/hooks/useAdminAPI';
import styles from './admin.module.css';

// 오늘 날짜를 YYYY-MM-DD 형식으로 반환
const getTodayString = () => {
    const today = new Date();
    return today.toISOString().split('T')[0];
};

// 한국 시간 포맷팅
const formatKoreanTime = (isoString) => {
    const date = new Date(isoString);
    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}:${String(date.getSeconds()).padStart(2, '0')}`;
};

// ============ TAB 1: 대시보드 (이벤트 관리) ============
function DashboardTab() {
    const { data: dashboardData, isLoading: dashboardLoading } = useDashboardStats();
    const stats = dashboardData?.stats;

    const [selectedDate, setSelectedDate] = useState(getTodayString());
    const [isEditMode, setIsEditMode] = useState(false);
    const [isCreating, setIsCreating] = useState(false);
    const [eventForm, setEventForm] = useState({ eventName: '', eventType: 'allMembers' });

    // 404 오류를 무시하고 null로 처리
    const { data: eventData, isLoading: eventLoading, error: eventError } = useEventDetail(selectedDate);
    const updateEvent = useUpdateEvent();
    const deleteEvent = useDeleteEvent();

    const eventTypeOptions = ['allMembers', 'tripleS', 'gdgSKHU'];

    // eventData가 변경되면 eventForm 초기화
    useEffect(() => {
        if (eventData?.event) {
            setEventForm({
                eventName: eventData.event.eventName,
                eventType: eventData.event.eventType,
            });
        } else {
            setEventForm({ eventName: '', eventType: 'allMembers' });
        }
    }, [eventData?.event]);

    const handleCreateEvent = async () => {
        if (!eventForm.eventName.trim()) {
            alert('이벤트명을 입력해주세요.');
            return;
        }

        try {
            // 실제로는 POST /api/events를 호출해야 함
            // 현재는 이벤트 생성 API를 사용하지 않고 setup 사용
            await fetch(`${process.env.NEXT_PUBLIC_API_BASE_URL}/event/setup`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    date: selectedDate,
                    eventName: eventForm.eventName,
                    eventType: eventForm.eventType,
                }),
            });
            alert('이벤트가 생성되었습니다.');
            setIsCreating(false);
            setEventForm({ eventName: '', eventType: 'allMembers' });
        } catch (error) {
            alert(`오류: ${error.message}`);
        }
    };

    const handleUpdateEvent = async () => {
        if (!eventForm.eventName.trim()) {
            alert('이벤트명을 입력해주세요.');
            return;
        }

        try {
            await updateEvent.mutateAsync({
                date: selectedDate,
                data: { eventName: eventForm.eventName, eventType: eventForm.eventType },
            });
            alert('이벤트가 수정되었습니다.');
        } catch (error) {
            alert(`오류: ${error.message}`);
        }
    };

    const handleDeleteEvent = async () => {
        if (!confirm('이 이벤트를 삭제하시겠습니까?')) return;

        try {
            await deleteEvent.mutateAsync(selectedDate);
            alert('이벤트가 삭제되었습니다.');
            setIsCreating(false);
            setEventForm({ eventName: '', eventType: 'allMembers' });
        } catch (error) {
            alert(`오류: ${error.message}`);
        }
    };

    const hasEvent = eventData?.event;

    if (dashboardLoading) return <div className={styles.loading}>로딩 중...</div>;

    return (
        <div className={styles.tabContent}>
            <h2>대시보드</h2>

            {/* 날짜 선택 및 이벤트 관리 */}
            <div className={styles.eventManagement}>
                <div className={styles.dateSelector}>
                    <label htmlFor="dateInput">날짜 선택:</label>
                    <input
                        id="dateInput"
                        type="date"
                        value={selectedDate}
                        onChange={(e) => {
                            setSelectedDate(e.target.value);
                            setIsCreating(false);
                            setEventForm({ eventName: '', eventType: 'allMembers' });
                        }}
                        className={styles.dateInput}
                    />
                </div>

                {eventLoading && (
                    <div className={styles.loadingSmall}>이벤트 정보 로딩 중...</div>
                )}

                {!eventLoading && (
                    <>
                        {/* 이벤트가 없을 때: 생성 버튼만 표시 */}
                        {!hasEvent && !isCreating && (
                            <button className={styles.createBtn} onClick={() => setIsCreating(true)}>
                                + 이벤트 생성
                            </button>
                        )}

                        {/* 이벤트가 없고 생성 모드: 생성 폼 표시 */}
                        {!hasEvent && isCreating && (
                            <div className={styles.eventFormContainer}>
                                <input
                                    type="text"
                                    placeholder="이벤트명"
                                    value={eventForm.eventName}
                                    onChange={(e) => setEventForm(prev => ({ ...prev, eventName: e.target.value }))}
                                    className={styles.eventInput}
                                />
                                <select
                                    value={eventForm.eventType}
                                    onChange={(e) => setEventForm(prev => ({ ...prev, eventType: e.target.value }))}
                                    className={styles.eventSelect}
                                >
                                    {eventTypeOptions.map(type => (
                                        <option key={type} value={type}>{type}</option>
                                    ))}
                                </select>

                                <div className={styles.eventButtonGroup}>
                                    <button className={styles.primaryBtn} onClick={handleCreateEvent}>
                                        생성
                                    </button>
                                    <button className={styles.secondaryBtn} onClick={() => {
                                        setIsCreating(false);
                                        setEventForm({ eventName: '', eventType: 'allMembers' });
                                    }}>
                                        취소
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* 이벤트가 있을 때: 수정/삭제 폼 표시 */}
                        {hasEvent && (
                            <div className={styles.eventFormContainer}>
                                <input
                                    type="text"
                                    placeholder="이벤트명"
                                    value={eventForm.eventName}
                                    onChange={(e) => setEventForm(prev => ({ ...prev, eventName: e.target.value }))}
                                    className={styles.eventInput}
                                />
                                <select
                                    value={eventForm.eventType}
                                    onChange={(e) => setEventForm(prev => ({ ...prev, eventType: e.target.value }))}
                                    className={styles.eventSelect}
                                >
                                    {eventTypeOptions.map(type => (
                                        <option key={type} value={type}>{type}</option>
                                    ))}
                                </select>

                                <div className={styles.eventButtonGroup}>
                                    <button className={styles.primaryBtn} onClick={handleUpdateEvent} disabled={updateEvent.isPending}>
                                        {updateEvent.isPending ? '수정 중...' : '수정'}
                                    </button>
                                    <button className={styles.dangerBtn} onClick={handleDeleteEvent} disabled={deleteEvent.isPending}>
                                        {deleteEvent.isPending ? '삭제 중...' : '삭제'}
                                    </button>
                                </div>
                            </div>
                        )}
                    </>
                )}
            </div>

            {/* 기존 대시보드 통계 */}
            {stats && (
                <div className={styles.statsGrid}>
                    <div className={styles.statCard}>
                        <div className={styles.statLabel}>오늘 이벤트</div>
                        <div className={styles.statValue}>{stats.eventName}</div>
                        <div className={styles.statSubtext}>타입: {stats.eventType}</div>
                    </div>

                    <div className={styles.statCard}>
                        <div className={styles.statLabel}>참가 인원</div>
                        <div className={styles.statValue}>{stats.totalParticipants}</div>
                        <div className={styles.statSubtext}>등록된 인원</div>
                    </div>

                    <div className={styles.statCard}>
                        <div className={styles.statLabel}>체크인율</div>
                        <div className={styles.statValue}>{stats.todayCheckInPercentage}%</div>
                        <div className={styles.statSubtext}>
                            {stats.todayCheckInCount} / {stats.totalParticipants}
                        </div>
                    </div>

                    <div className={styles.statCard}>
                        <div className={styles.statLabel}>전체 멤버</div>
                        <div className={styles.statValue}>{stats.totalMembers}</div>
                        <div className={styles.statSubtext}>등록된 멤버</div>
                    </div>
                </div>
            )}

            {stats?.typeStats && Object.keys(stats.typeStats).length > 0 && (
                <div className={styles.typeStatsSection}>
                    <h3>타입별 멤버 분포</h3>
                    <div className={styles.typeStatsList}>
                        {Object.entries(stats.typeStats).map(([type, count]) => (
                            <div key={type} className={styles.typeStatItem}>
                                <span className={styles.typeName}>{type}</span>
                                <span className={styles.typeCount}>{count}명</span>
                            </div>
                        ))}
                    </div>
                </div>
            )}
        </div>
    );
}

// ============ TAB 2: 멤버 관리 (멤버 정보 + 체크인) ============
function MemberManagementTab() {
    const queryClient = useQueryClient();
    const { data: membersData, isLoading } = useMembers();
    const { data: dashboardData } = useDashboardStats();
    const updateMember = useUpdateMember();
    const manualCheckIn = useManualCheckIn();
    const cancelCheckIn = useCancelCheckIn();
    const updateMemo = useUpdateMemo();

    const [searchTerm, setSearchTerm] = useState('');
    const [filterType, setFilterType] = useState('all');
    const [expandedPhoneKey, setExpandedPhoneKey] = useState(null);
    const [editingTypes, setEditingTypes] = useState({});
    const [memoInput, setMemoInput] = useState({});
    const [checkedInMembers, setCheckedInMembers] = useState({});
    const [savingMemo, setSavingMemo] = useState({});
    const [isRefreshing, setIsRefreshing] = useState(false);

    const members = membersData?.members || [];
    const todayDate = getTodayString();
    const isEventExists = !!dashboardData?.stats?.eventName;

    // 체크인 상태 추적
    const fetchCheckedInStatus = useCallback(async () => {
        try {
            const response = await fetch(`${process.env.NEXT_PUBLIC_API_BASE_URL}/realtime/checkin`);
            if (!response.ok) {
                if (response.status === 404) {
                    // 이벤트가 없음 - 정상
                    setCheckedInMembers({});
                    setMemoInput({});
                    return;
                }
                console.error('Failed to fetch checked-in status:', response.status);
                return;
            }
            const data = await response.json();
            if (data.data?.checkedIn) {
                const checkedInObj = {};
                data.data.checkedIn.forEach(m => {
                    checkedInObj[m.phoneKey] = m;
                });
                setCheckedInMembers(checkedInObj);
                // 체크인 멤버의 메모로 memoInput 초기화
                const initialMemos = {};
                data.data.checkedIn.forEach(m => {
                    if (m.memo) initialMemos[m.phoneKey] = m.memo;
                });
                setMemoInput(initialMemos);
            } else {
                setCheckedInMembers({});
                setMemoInput({});
            }
        } catch (error) {
            console.error('Failed to fetch checked-in status:', error);
            // 오류 발생해도 계속 진행 (UI 깨지지 않도록)
            setCheckedInMembers({});
            setMemoInput({});
        }
    }, []);

    // 초기 로드만 수행 (자동갱신 안 함)
    useEffect(() => {
        fetchCheckedInStatus();
    }, []);

    // 필터링 및 검색
    const filteredMembers = useMemo(() => {
        return members.filter(member => {
            const matchesSearch =
                member.name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
                member.phoneNumber?.includes(searchTerm);

            if (filterType === 'all') return matchesSearch;

            const memberTypes = Array.isArray(member.types) ? member.types : [member.types];
            return matchesSearch && memberTypes.includes(filterType);
        });
    }, [members, searchTerm, filterType]);

    // 타입 변경 처리
    const handleTypeChange = useCallback((phoneKey, newTypes) => {
        setEditingTypes(prev => ({ ...prev, [phoneKey]: newTypes }));
    }, []);

    // 타입 저장
    const handleSaveTypes = useCallback(async (phoneKey) => {
        const newTypes = editingTypes[phoneKey];
        if (!newTypes || newTypes.length === 0) {
            alert('최소 하나의 타입을 선택해주세요.');
            return;
        }

        try {
            await updateMember.mutateAsync({
                phoneKey,
                data: { types: newTypes },
            });
            // 성공 후 editingTypes 제거 (UI 갱신)
            setEditingTypes(prev => {
                const updated = { ...prev };
                delete updated[phoneKey];
                return updated;
            });
            alert('타입이 변경되었습니다.');
        } catch (error) {
            alert(`오류: ${error.message}`);
        }
    }, [editingTypes, updateMember]);

    // 수동 체크인 (이벤트 자동 생성)
    const handleManualCheckIn = useCallback(async (phoneKey) => {
        try {
            // 이벤트 존재 여부 확인
            const hasEvent = dashboardData?.stats?.eventName;

            // 이벤트가 없으면 자동으로 생성
            if (!hasEvent) {
                const createResponse = await fetch(`${process.env.NEXT_PUBLIC_API_BASE_URL}/event/setup`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        date: todayDate,
                        eventName: '자동 생성 이벤트',
                        eventType: 'allMembers',
                    }),
                });

                if (!createResponse.ok) {
                    throw new Error('이벤트 생성 실패');
                }

                // 대시보드 데이터 캐시 무효화
                await queryClient.invalidateQueries({ queryKey: ['dashboardStats'] });
            }

            // 체크인 수행
            await manualCheckIn.mutateAsync({ phoneKey, date: todayDate });
            await fetchCheckedInStatus();
            alert('체크인 되었습니다.');
        } catch (error) {
            let errorMessage = error.message;

            // 사용자 친화적인 오류 메시지
            if (error.message.includes('참가자 아님')) {
                errorMessage = '이 멤버는 현재 이벤트에 등록되지 않았습니다. 이벤트 설정에서 멤버를 추가해주세요.';
            } else if (error.message.includes('이미 체크인됨')) {
                errorMessage = '이미 체크인된 멤버입니다.';
            } else if (error.message.includes('이벤트 없음')) {
                errorMessage = '이벤트를 찾을 수 없습니다. 먼저 이벤트를 생성해주세요.';
            } else if (error.message.includes('멤버 없음')) {
                errorMessage = '이 멤버를 찾을 수 없습니다.';
            }

            alert(`오류: ${errorMessage}`);
        }
    }, [manualCheckIn, todayDate, fetchCheckedInStatus, dashboardData?.stats?.eventName, queryClient]);

    // 체크인 취소
    const handleCancelCheckIn = useCallback(async (phoneKey) => {
        try {
            await cancelCheckIn.mutateAsync({ date: todayDate, phoneKey });
            await fetchCheckedInStatus();
            alert('체크인이 취소되었습니다.');
        } catch (error) {
            alert(`오류: ${error.message}`);
        }
    }, [cancelCheckIn, todayDate, fetchCheckedInStatus]);

    // 메모 저장
    const handleSaveMemo = useCallback(async (phoneKey) => {
        const memo = memoInput[phoneKey];
        if (memo === undefined) return;

        setSavingMemo(prev => ({ ...prev, [phoneKey]: true }));

        try {
            await updateMemo.mutateAsync({ date: todayDate, phoneKey, memo });
            // 체크인 상태 다시 조회해서 메모 업데이트
            await fetchCheckedInStatus();
            alert('메모가 저장되었습니다.');
        } catch (error) {
            alert(`오류: ${error.message}`);
        } finally {
            setSavingMemo(prev => ({ ...prev, [phoneKey]: false }));
        }
    }, [updateMemo, todayDate, memoInput, fetchCheckedInStatus]);

    if (isLoading) return <div className={styles.loading}>로딩 중...</div>;

    const typeOptions = ['allMembers', 'tripleS', 'gdgSKHU'];

    const handleRefresh = async () => {
        setIsRefreshing(true);
        try {
            await fetchCheckedInStatus();
        } finally {
            setIsRefreshing(false);
        }
    };

    return (
        <div className={styles.tabContent}>
            <div className={styles.tabHeader}>
                <h2>멤버 관리</h2>
                <button
                    className={styles.refreshIconBtn}
                    onClick={handleRefresh}
                    disabled={isRefreshing}
                    title="체크인 상태 새로고침"
                >
                    {isRefreshing ? '갱신중...' : '새로고침'}
                </button>
            </div>

            <div className={styles.controls}>
                <input
                    type="text"
                    placeholder="이름 또는 전화번호로 검색..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className={styles.searchInput}
                />
                <select
                    value={filterType}
                    onChange={(e) => setFilterType(e.target.value)}
                    className={styles.filterSelect}
                >
                    <option value="all">모든 타입</option>
                    {typeOptions.map(type => (
                        <option key={type} value={type}>{type}</option>
                    ))}
                </select>
            </div>

            <div className={styles.memberList}>
                <div className={styles.memberListHeader}>
                    <div className={styles.colName}>이름</div>
                    <div className={styles.colGen}>팀</div>
                    <div className={styles.colPart}>파트</div>
                    <div className={styles.colPhone}>전화</div>
                    <div className={styles.colSchool}>학교</div>
                    <div className={styles.colCheckIn}>상태</div>
                    <div className={styles.colMemo}>메모</div>
                    <div className={styles.colActions}>작업</div>
                </div>

                {filteredMembers.map(member => {
                    const memberTypes = Array.isArray(member.types) ? member.types : (member.types ? [member.types] : ['allMembers']);
                    const isExpanded = expandedPhoneKey === member.phoneKey;
                    const currentEditingTypes = editingTypes[member.phoneKey] ?? memberTypes;
                    const checkedInData = checkedInMembers[member.phoneKey];
                    const isCheckedIn = !!checkedInData;

                    return (
                        <div key={member.phoneKey} className={styles.memberRow}>
                            <div className={styles.colName}>{member.name}</div>
                            <div className={styles.colGen}>{member.gen || '-'}</div>
                            <div className={styles.colPart}>{member.part}</div>
                            <div className={styles.colPhone}>{member.phoneNumber}</div>
                            <div className={styles.colSchool}>{member.school || '-'}</div>
                            <div className={styles.colCheckIn}>
                                <span className={isCheckedIn ? styles.checkedInBadge : styles.notCheckedInBadge}>
                                    {isCheckedIn ? '✓ 체크인' : '✗ 미체크인'}
                                </span>
                            </div>
                            <div className={styles.colMemo}>
                                {isCheckedIn && isEventExists ? (
                                    <input
                                        type="text"
                                        value={memoInput[member.phoneKey] ?? ''}
                                        onChange={(e) => setMemoInput(prev => ({ ...prev, [member.phoneKey]: e.target.value }))}
                                        placeholder="메모 입력"
                                        className={styles.memoInputSmall}
                                    />
                                ) : (
                                    <span>{checkedInData?.memo || '-'}</span>
                                )}
                            </div>
                            <div className={styles.colActions}>
                                <div className={styles.actionButtonGroup}>
                                    {!isCheckedIn ? (
                                        <button
                                            className={styles.checkInBtn}
                                            onClick={() => handleManualCheckIn(member.phoneKey)}
                                            disabled={manualCheckIn.isPending}
                                            title="수동 체크인"
                                        >
                                            체크인
                                        </button>
                                    ) : (
                                        <>
                                            <button
                                                className={styles.cancelBtn}
                                                onClick={() => handleCancelCheckIn(member.phoneKey)}
                                                disabled={cancelCheckIn.isPending}
                                                title="체크인 취소"
                                            >
                                                취소
                                            </button>
                                            {isEventExists && (
                                                <button
                                                    className={styles.saveMemoBtn}
                                                    onClick={() => handleSaveMemo(member.phoneKey)}
                                                    disabled={updateMemo.isPending || savingMemo[member.phoneKey]}
                                                    title="메모 저장"
                                                >
                                                    {savingMemo[member.phoneKey] ? '저장중' : '저장'}
                                                </button>
                                            )}
                                        </>
                                    )}
                                    <button
                                        className={styles.typeBtn}
                                        onClick={() => setExpandedPhoneKey(isExpanded ? null : member.phoneKey)}
                                        title="타입 관리"
                                    >
                                        {isExpanded ? '접기' : '타입'}
                                    </button>
                                </div>
                            </div>

                            {isExpanded && (
                                <div className={styles.expandedSection}>
                                    {/* 멤버 상세 정보 */}
                                    <div className={styles.memberDetails}>
                                        <div>phoneKey: {member.phoneKey}</div>
                                        <div>학교: {member.school || '-'}</div>
                                        <div>직책: {member.position || '-'}</div>
                                    </div>

                                    {/* 타입 관리 */}
                                    <div className={styles.typeSelector}>
                                        <label>타입 관리:</label>
                                        <div className={styles.typeCheckboxes}>
                                            {typeOptions.map(type => (
                                                <label key={type} className={styles.checkbox}>
                                                    <input
                                                        type="checkbox"
                                                        checked={currentEditingTypes.includes(type)}
                                                        onChange={(e) => {
                                                            if (e.target.checked) {
                                                                handleTypeChange(member.phoneKey, [...currentEditingTypes, type]);
                                                            } else {
                                                                handleTypeChange(
                                                                    member.phoneKey,
                                                                    currentEditingTypes.filter(t => t !== type)
                                                                );
                                                            }
                                                        }}
                                                    />
                                                    {type}
                                                </label>
                                            ))}
                                        </div>
                                        <button
                                            className={styles.saveBtn}
                                            onClick={() => handleSaveTypes(member.phoneKey)}
                                            disabled={updateMember.isPending}
                                        >
                                            {updateMember.isPending ? '저장 중...' : '저장'}
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>

            <div className={styles.memberCount}>
                총 {filteredMembers.length}명
            </div>
        </div>
    );
}

// ============ TAB 3: 실시간 현황 (체크인 멤버 표시) ============
function RealtimeStatusTab() {
    const [autoRefresh, setAutoRefresh] = useState(false);
    const { data, isLoading, refetch } = useRealtimeCheckin(autoRefresh);
    const realtimeData = data?.data;

    if (isLoading) return <div className={styles.loading}>로딩 중...</div>;

    if (!realtimeData) {
        return (
            <div className={styles.tabContent}>
                <h2>실시간 현황</h2>
                <div className={styles.emptyState}>오늘 이벤트가 없습니다.</div>
            </div>
        );
    }

    const { stats, checkedIn, notCheckedIn } = realtimeData;

    return (
        <div className={styles.tabContent}>
            <h2>실시간 현황</h2>

            <div className={styles.realtimeControls}>
                <label className={styles.autoRefreshToggle}>
                    <input
                        type="checkbox"
                        checked={autoRefresh}
                        onChange={(e) => setAutoRefresh(e.target.checked)}
                    />
                    자동 갱신 (5초)
                </label>
                <button className={styles.refreshBtn} onClick={() => refetch()}>
                    새로고침
                </button>
            </div>

            <div className={styles.realtimeStats}>
                <div className={styles.rtStatCard}>
                    <div className={styles.rtStatLabel}>총 인원</div>
                    <div className={styles.rtStatValue}>{stats.totalParticipants}</div>
                </div>
                <div className={styles.rtStatCard}>
                    <div className={styles.rtStatLabel}>체크인</div>
                    <div className={styles.rtStatValue} style={{ color: '#22c55e' }}>
                        {stats.checkedInCount}
                    </div>
                </div>
                <div className={styles.rtStatCard}>
                    <div className={styles.rtStatLabel}>미체크인</div>
                    <div className={styles.rtStatValue} style={{ color: '#ef4444' }}>
                        {stats.notCheckedInCount}
                    </div>
                </div>
                <div className={styles.rtStatCard}>
                    <div className={styles.rtStatLabel}>진행률</div>
                    <div className={styles.rtStatValue}>{stats.percentage}%</div>
                </div>
            </div>

            {/* 체크인 멤버 테이블 */}
            {checkedIn.length > 0 && (
                <div className={styles.checkedInSection}>
                    <h3>최근 체크인 참가자 ({checkedIn.length}명)</h3>
                    <table className={styles.checkedInTable}>
                        <thead>
                            <tr>
                                <th>체크인 시간</th>
                                <th>이름</th>
                                <th>전화번호</th>
                                <th>파트</th>
                                <th>학교</th>
                                <th>타입</th>
                                <th>메모</th>
                            </tr>
                        </thead>
                        <tbody>
                            {checkedIn.map(member => {
                                const memberTypes = Array.isArray(member.types) ? member.types : (member.types ? [member.types] : []);
                                return (
                                    <tr key={member.phoneKey}>
                                        <td>{formatKoreanTime(member.checkedInAt)}</td>
                                        <td>{member.name}</td>
                                        <td>{member.phoneNumber}</td>
                                        <td>{member.part}</td>
                                        <td>{member.school || '-'}</td>
                                        <td>{memberTypes.join(', ') || '-'}</td>
                                        <td>{member.memo || '-'}</td>
                                    </tr>
                                );
                            })}
                        </tbody>
                    </table>
                </div>
            )}

            {notCheckedIn.length > 0 && (
                <div className={styles.notCheckedInSection}>
                    <h3>미체크인 멤버 ({notCheckedIn.length}명)</h3>
                    <div className={styles.notCheckedInList}>
                        {notCheckedIn.map(member => (
                            <div key={member.phoneKey} className={styles.notCheckedInItem}>
                                <span className={styles.memberName}>{member.name}</span>
                                <span className={styles.memberPart}>{member.part}</span>
                            </div>
                        ))}
                    </div>
                </div>
            )}
        </div>
    );
}

// ============ TAB 4: 기존 내역 (과거 이벤트 조회) ============
function HistoryTab() {
    const { data: eventsData, isLoading: eventsLoading } = useEvents();
    const [selectedDate, setSelectedDate] = useState(null);
    const { data: detailData, isLoading: detailLoading } = useEventDetail(selectedDate);

    if (eventsLoading) return <div className={styles.loading}>로딩 중...</div>;

    const events = eventsData?.events || [];

    return (
        <div className={styles.tabContent}>
            <h2>기존 내역</h2>

            <div className={styles.historyContainer}>
                {/* 왼쪽: 이벤트 목록 */}
                <div className={styles.eventList}>
                    {events.length === 0 ? (
                        <div className={styles.emptyState}>이벤트 내역이 없습니다.</div>
                    ) : (
                        events.map(event => (
                            <div
                                key={event.date}
                                className={`${styles.eventCard} ${selectedDate === event.date ? styles.active : ''}`}
                                onClick={() => setSelectedDate(event.date)}
                            >
                                <h3>{event.eventName}</h3>
                                <p className={styles.eventDate}>{event.date}</p>
                                <p className={styles.eventType}>타입: {event.eventType}</p>
                                <p className={styles.eventRate}>체크인율: {event.checkInRate}% ({event.checkedInCount}/{event.totalParticipants})</p>
                            </div>
                        ))
                    )}
                </div>

                {/* 오른쪽: 이벤트 상세 */}
                {selectedDate && (
                    <div className={styles.detailPanel}>
                        {detailLoading ? (
                            <div className={styles.loading}>로딩 중...</div>
                        ) : detailData ? (
                            <div className={styles.detailContent}>
                                <h3>{detailData.event.eventName}</h3>
                                <div className={styles.detailInfo}>
                                    <p>날짜: {selectedDate}</p>
                                    <p>타입: {detailData.event.eventType}</p>
                                    <p>참가인원: {detailData.event.participants?.length || 0}명</p>
                                </div>

                                {/* 체크인 멤버 테이블 */}
                                {detailData.checkedInMembers.length > 0 && (
                                    <div className={styles.checkedInSection}>
                                        <h4>체크인 멤버 ({detailData.checkedInMembers.length}명)</h4>
                                        <table className={styles.detailTable}>
                                            <thead>
                                                <tr>
                                                    <th>이름</th>
                                                    <th>직군</th>
                                                    <th>체크인 시간</th>
                                                    <th>메모</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {detailData.checkedInMembers.map(member => (
                                                    <tr key={member.phoneKey}>
                                                        <td>{member.name}</td>
                                                        <td>{member.part}</td>
                                                        <td>{formatKoreanTime(member.checkedInAt)}</td>
                                                        <td>{member.memo || '-'}</td>
                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                    </div>
                                )}

                                {/* 미체크인 멤버 */}
                                {detailData.notCheckedInMembers.length > 0 && (
                                    <div className={styles.notCheckedInSection}>
                                        <h4>미체크인 멤버 ({detailData.notCheckedInMembers.length}명)</h4>
                                        <div className={styles.notCheckedInGrid}>
                                            {detailData.notCheckedInMembers.map(member => (
                                                <div key={member.phoneKey} className={styles.gridItem}>
                                                    {member.name} ({member.part})
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        ) : (
                            <div className={styles.emptyState}>이벤트 정보를 찾을 수 없습니다.</div>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
}

// ============ 메인 페이지 ============
export default function AdminPage() {
    const searchParams = useSearchParams();
    const activeTab = searchParams.get('tab') || 'dashboard';

    const tabs = [
        { id: 'dashboard', label: '대시보드', component: DashboardTab },
        { id: 'status', label: '멤버 관리', component: MemberManagementTab },
        { id: 'realtime', label: '실시간 현황', component: RealtimeStatusTab },
        { id: 'history', label: '기존 내역', component: HistoryTab },
    ];

    const ActiveComponent = tabs.find(tab => tab.id === activeTab)?.component || DashboardTab;

    return <ActiveComponent />;
}
